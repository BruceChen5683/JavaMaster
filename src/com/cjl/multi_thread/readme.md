某些编程语言被设计成可以将并发任务彼此隔离，函数式语言.
Erlang  某个部分大量使用并发，并且你在视图构建这个部分时碰到许多问题。
可以使用Erlang这类专门的并发语言创建这部分

Thread start方法在构造器中调用的，可能会变得有问题。
因为另一个任务可能会在构造器结束之前开始执行，这意味着
该任务能够访问处于不稳定状态的对象。
这是优选Executor而不是显示的创建Thread对象的另一个原因。

使用volatile而不是synchronized的唯一安全的情况是类中只有一个可变的域

如果一个域可能被多个任务同时访问，或者这些任务中至少有一个是写入任务，
那么就应该讲这个域设为volatile


TODO
写一个程序启动5个线程去争夺ReentrantLock,然后在AQS中设置断点，
结合线程对锁的获取和释放，观察AQS中head节点和同步队列的变化情况，然后绘制变化情况图，
图中应该标识出每个线程在获取和释放所后head节点和同步队列的变化。

使用AQS实现一个缩减版的FutureTask,实现RunnableFuture时，只需要实现get()方法即可，不考虑
cancel和异常的情况

分析JDK的FutureTask，写一篇技术分析文章